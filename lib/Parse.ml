(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_move_on_aptos"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "line_comment";
  "block_comment";
]

let children_regexps : (string * Run.exp option) list = [
  "pat_0x", None;
  "visibility",
  Some (
    Seq [
      Token (Literal "public");
      Opt (
        Seq [
          Token (Literal "(");
          Alt [|
            Token (Literal "script");
            Token (Literal "friend");
          |];
          Token (Literal ")");
        ];
      );
    ];
  );
  "number_type",
  Some (
    Alt [|
      Token (Literal "u8");
      Token (Literal "u16");
      Token (Literal "u32");
      Token (Literal "u64");
      Token (Literal "u128");
      Token (Literal "u256");
    |];
  );
  "ellipsis", None;
  "quantifier_directive",
  Some (
    Alt [|
      Token (Literal "exists");
      Token (Literal "forall");
      Token (Literal "choose");
      Token (Literal "min");
    |];
  );
  "tok_bdquot_rep_choice_imm_tok_bslash_choice_pat_9c2bd89_dquot",
  None;
  "phantom", None;
  "bool_literal",
  Some (
    Alt [|
      Token (Literal "true");
      Token (Literal "false");
    |];
  );
  "pat_c1c0c3a", None;
  "pat_0b", None;
  "imm_tok_lt", None;
  "pat_0o", None;
  "module_ident", None;
  "reuseable_keywords",
  Some (
    Alt [|
      Token (Literal "for");
      Token (Literal "while");
      Token (Literal "friend");
    |];
  );
  "pat_8bc5a9c", None;
  "identifier", None;
  "pat_57a456d", None;
  "tok_xdquot_pat_92a0a93_dquot", None;
  "pat_9bd0c11", None;
  "module_member_modifier",
  Some (
    Alt [|
      Token (Name "visibility");
      Token (Literal "native");
      Token (Literal "entry");
    |];
  );
  "primitive_type",
  Some (
    Alt [|
      Token (Name "number_type");
      Token (Literal "bool");
      Token (Literal "address");
      Token (Literal "vector");
    |];
  );
  "ability",
  Some (
    Alt [|
      Alt [|
        Token (Literal "copy");
        Token (Literal "drop");
        Token (Literal "store");
        Token (Literal "key");
      |];
      Token (Name "ellipsis");
    |];
  );
  "attribute_name",
  Some (
    Seq [
      Token (Name "identifier");
      Repeat (
        Seq [
          Token (Literal "::");
          Token (Name "identifier");
        ];
      );
    ];
  );
  "spec_apply_fragment",
  Some (
    Alt [|
      Token (Literal "*");
      Token (Name "identifier");
    |];
  );
  "copy_expr",
  Some (
    Seq [
      Token (Literal "copy");
      Token (Name "identifier");
    ];
  );
  "use_alias",
  Some (
    Seq [
      Token (Literal "as");
      Token (Name "identifier");
    ];
  );
  "move_expr",
  Some (
    Seq [
      Token (Literal "move");
      Token (Name "identifier");
    ];
  );
  "byte_string",
  Some (
    Alt [|
      Token (Name "tok_xdquot_pat_92a0a93_dquot");
      Token (Name "tok_bdquot_rep_choice_imm_tok_bslash_choice_pat_9c2bd89_dquot");
    |];
  );
  "number",
  Some (
    Alt [|
      Token (Name "pat_57a456d");
      Seq [
        Token (Name "pat_0x");
        Token (Name "pat_c1c0c3a");
      ];
      Seq [
        Token (Name "pat_0b");
        Token (Name "pat_8bc5a9c");
      ];
      Seq [
        Token (Name "pat_0o");
        Token (Name "pat_9bd0c11");
      ];
    |];
  );
  "discouraged_name",
  Some (
    Alt [|
      Token (Name "primitive_type");
      Token (Name "quantifier_directive");
      Token (Name "reuseable_keywords");
    |];
  );
  "constraints",
  Some (
    Seq [
      Token (Literal ":");
      Token (Name "ability");
      Repeat (
        Seq [
          Token (Literal "+");
          Token (Name "ability");
        ];
      );
    ];
  );
  "abilities",
  Some (
    Seq [
      Token (Name "ability");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "ability");
        ];
      );
    ];
  );
  "use_member",
  Some (
    Alt [|
      Seq [
        Token (Name "identifier");
        Opt (
          Token (Name "use_alias");
        );
      ];
      Token (Name "ellipsis");
    |];
  );
  "numerical_addr", Some (Token (Name "number"););
  "typed_number",
  Some (
    Seq [
      Token (Name "number");
      Token (Name "number_type");
    ];
  );
  "var_name",
  Some (
    Alt [|
      Token (Name "identifier");
      Token (Name "discouraged_name");
    |];
  );
  "type_param",
  Some (
    Alt [|
      Seq [
        Token (Name "identifier");
        Opt (
          Token (Name "constraints");
        );
      ];
      Token (Name "ellipsis");
    |];
  );
  "leading_name_access_wildcard",
  Some (
    Alt [|
      Token (Name "numerical_addr");
      Alt [|
        Token (Name "identifier");
        Token (Literal "*");
      |];
    |];
  );
  "leading_name_access",
  Some (
    Alt [|
      Token (Name "numerical_addr");
      Token (Name "identifier");
    |];
  );
  "type_params",
  Some (
    Seq [
      Token (Literal "<");
      Opt (
        Seq [
          Token (Name "type_param");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "type_param");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ">");
    ];
  );
  "struct_type_parameter",
  Some (
    Seq [
      Opt (
        Token (Name "phantom");
      );
      Token (Name "type_param");
    ];
  );
  "name_access_chain_wildcard",
  Some (
    Alt [|
      Alt [|
        Alt [|
          Token (Name "identifier");
          Token (Literal "*");
        |];
        Token (Name "discouraged_name");
      |];
      Seq [
        Alt [|
          Token (Name "leading_name_access_wildcard");
          Token (Name "discouraged_name");
        |];
        Token (Literal "::");
        Alt [|
          Token (Name "identifier");
          Token (Literal "*");
        |];
        Opt (
          Seq [
            Token (Literal "::");
            Alt [|
              Token (Name "identifier");
              Token (Literal "*");
            |];
          ];
        );
      ];
    |];
  );
  "module_ident_",
  Some (
    Seq [
      Token (Name "leading_name_access");
      Token (Literal "::");
      Token (Name "identifier");
    ];
  );
  "name_access_chain",
  Some (
    Alt [|
      Alt [|
        Token (Name "identifier");
        Token (Name "discouraged_name");
      |];
      Seq [
        Alt [|
          Token (Name "leading_name_access");
          Token (Name "discouraged_name");
        |];
        Token (Literal "::");
        Token (Name "identifier");
        Opt (
          Seq [
            Token (Literal "::");
            Token (Name "identifier");
          ];
        );
      ];
    |];
  );
  "value",
  Some (
    Alt [|
      Seq [
        Token (Literal "@");
        Token (Name "leading_name_access");
      ];
      Token (Name "bool_literal");
      Token (Name "number");
      Token (Name "typed_number");
      Token (Name "byte_string");
    |];
  );
  "spec_apply_pattern",
  Some (
    Seq [
      Opt (
        Alt [|
          Token (Literal "public");
          Token (Literal "internal");
        |];
      );
      Repeat1 (
        Token (Name "spec_apply_fragment");
      );
      Opt (
        Token (Name "type_params");
      );
    ];
  );
  "struct_type_params",
  Some (
    Seq [
      Token (Literal "<");
      Opt (
        Seq [
          Token (Name "struct_type_parameter");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "struct_type_parameter");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ">");
    ];
  );
  "use_decl",
  Some (
    Seq [
      Token (Literal "use");
      Token (Name "module_ident_");
      Alt [|
        Opt (
          Token (Name "use_alias");
        );
        Seq [
          Token (Literal "::");
          Token (Name "use_member");
        ];
        Seq [
          Token (Literal "::");
          Token (Literal "{");
          Opt (
            Seq [
              Token (Name "use_member");
              Repeat (
                Seq [
                  Token (Literal ",");
                  Token (Name "use_member");
                ];
              );
            ];
          );
          Opt (
            Token (Literal ",");
          );
          Token (Literal "}");
        ];
      |];
      Token (Literal ";");
    ];
  );
  "closure_type",
  Some (
    Seq [
      Token (Literal "|");
      Opt (
        Seq [
          Token (Name "type_");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "type_");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "|");
      Opt (
        Token (Name "type_");
      );
    ];
  );
  "ref_type",
  Some (
    Alt [|
      Seq [
        Token (Literal "&");
        Token (Name "type");
      ];
      Seq [
        Token (Literal "&mut");
        Token (Name "type");
      ];
    |];
  );
  "tuple_type",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "type_");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "type_");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ")");
    ];
  );
  "type",
  Some (
    Alt [|
      Seq [
        Alt [|
          Token (Name "name_access_chain");
          Token (Name "primitive_type");
        |];
        Opt (
          Token (Name "type_args");
        );
      ];
      Token (Name "closure_type");
      Token (Name "tuple_type");
    |];
  );
  "type_",
  Some (
    Alt [|
      Token (Name "type");
      Token (Name "ref_type");
      Token (Name "ellipsis");
    |];
  );
  "type_args",
  Some (
    Seq [
      Token (Name "imm_tok_lt");
      Opt (
        Seq [
          Token (Name "type_");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "type_");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ">");
    ];
  );
  "friend_decl",
  Some (
    Seq [
      Token (Literal "friend");
      Token (Name "name_access_chain");
      Token (Literal ";");
    ];
  );
  "attribute_val",
  Some (
    Alt [|
      Token (Name "value");
      Token (Name "name_access_chain");
    |];
  );
  "spec_pragma_prop",
  Some (
    Seq [
      Token (Name "var_name");
      Opt (
        Seq [
          Token (Literal "=");
          Alt [|
            Token (Name "value");
            Token (Name "name_access_chain");
          |];
        ];
      );
    ];
  );
  "struct_def_name",
  Some (
    Seq [
      Token (Name "identifier");
      Opt (
        Token (Name "struct_type_params");
      );
    ];
  );
  "var",
  Some (
    Seq [
      Token (Name "name_access_chain");
      Opt (
        Token (Name "type_args");
      );
    ];
  );
  "typed_metavariable",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "identifier");
      Token (Literal ":");
      Token (Name "type_");
      Token (Literal ")");
    ];
  );
  "bind",
  Some (
    Alt [|
      Token (Name "var_name");
      Seq [
        Token (Name "name_access_chain");
        Opt (
          Token (Name "type_args");
        );
        Token (Name "bind_fields");
      ];
      Token (Name "ellipsis");
    |];
  );
  "bind_field",
  Some (
    Alt [|
      Alt [|
        Token (Name "var_name");
        Seq [
          Token (Name "var_name");
          Token (Literal ":");
          Token (Name "bind");
        ];
      |];
      Token (Name "ellipsis");
    |];
  );
  "bind_fields",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "bind_field");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "bind_field");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "address_specifier",
  Some (
    Alt [|
      Token (Literal "*");
      Token (Name "numerical_addr");
      Seq [
        Token (Name "name_access_chain");
        Opt (
          Seq [
            Opt (
              Token (Name "type_args");
            );
            Token (Literal "(");
            Token (Name "identifier");
            Token (Literal ")");
          ];
        );
      ];
    |];
  );
  "parameter",
  Some (
    Alt [|
      Seq [
        Token (Name "identifier");
        Token (Literal ":");
        Token (Name "type_");
      ];
      Token (Name "ellipsis");
    |];
  );
  "field_annot",
  Some (
    Alt [|
      Seq [
        Token (Name "identifier");
        Token (Literal ":");
        Token (Name "type_");
      ];
      Token (Name "ellipsis");
    |];
  );
  "attribute",
  Some (
    Alt [|
      Alt [|
        Token (Name "attribute_name");
        Seq [
          Token (Name "attribute_name");
          Token (Literal "=");
          Token (Name "attribute_val");
        ];
        Seq [
          Token (Name "attribute_name");
          Token (Literal "(");
          Opt (
            Seq [
              Token (Name "attribute");
              Repeat (
                Seq [
                  Token (Literal ",");
                  Token (Name "attribute");
                ];
              );
            ];
          );
          Opt (
            Token (Literal ",");
          );
          Token (Literal ")");
        ];
      |];
      Token (Name "ellipsis");
    |];
  );
  "condition_props",
  Some (
    Seq [
      Token (Literal "[");
      Opt (
        Seq [
          Token (Name "spec_pragma_prop");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "spec_pragma_prop");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "]");
    ];
  );
  "spec_pragma",
  Some (
    Seq [
      Token (Literal "pragma");
      Opt (
        Seq [
          Token (Name "spec_pragma_prop");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "spec_pragma_prop");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ";");
    ];
  );
  "bind_list",
  Some (
    Alt [|
      Token (Name "bind");
      Seq [
        Token (Literal "(");
        Opt (
          Seq [
            Token (Name "bind");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "bind");
              ];
            );
          ];
        );
        Opt (
          Token (Literal ",");
        );
        Token (Literal ")");
      ];
    |];
  );
  "lambda_bind_list",
  Some (
    Seq [
      Token (Literal "|");
      Opt (
        Seq [
          Token (Name "bind");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "bind");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "|");
    ];
  );
  "access_specifier",
  Some (
    Seq [
      Token (Name "name_access_chain_wildcard");
      Opt (
        Token (Name "type_args");
      );
      Opt (
        Seq [
          Token (Literal "(");
          Token (Name "address_specifier");
          Token (Literal ")");
        ];
      );
    ];
  );
  "parameters",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "parameter");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "parameter");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ")");
    ];
  );
  "struct_body",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "field_annot");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "field_annot");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "attributes",
  Some (
    Repeat1 (
      Seq [
        Token (Literal "#");
        Token (Literal "[");
        Opt (
          Seq [
            Token (Name "attribute");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "attribute");
              ];
            );
          ];
        );
        Opt (
          Token (Literal ",");
        );
        Token (Literal "]");
      ];
    );
  );
  "access_specifier_list",
  Some (
    Seq [
      Token (Name "access_specifier");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "access_specifier");
        ];
      );
      Opt (
        Token (Literal ",");
      );
    ];
  );
  "spec_target_signature_opt",
  Some (
    Seq [
      Opt (
        Token (Name "type_params");
      );
      Token (Name "parameters");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "type_");
        ];
      );
    ];
  );
  "spec_func_signatures",
  Some (
    Seq [
      Token (Name "identifier");
      Opt (
        Token (Name "type_params");
      );
      Token (Name "parameters");
      Token (Literal ":");
      Token (Name "type_");
    ];
  );
  "struct_decl",
  Some (
    Seq [
      Token (Literal "struct");
      Token (Name "struct_def_name");
      Opt (
        Seq [
          Token (Literal "has");
          Token (Name "abilities");
        ];
      );
      Alt [|
        Token (Name "struct_body");
        Token (Literal ";");
      |];
    ];
  );
  "script_user_decl",
  Some (
    Seq [
      Opt (
        Token (Name "attributes");
      );
      Token (Name "use_decl");
    ];
  );
  "specifier",
  Some (
    Alt [|
      Token (Literal "pure");
      Repeat1 (
        Seq [
          Opt (
            Token (Literal "!");
          );
          Alt [|
            Token (Literal "acquires");
            Token (Literal "reads");
            Token (Literal "writes");
          |];
          Token (Name "access_specifier_list");
        ];
      );
    |];
  );
  "spec_block_target",
  Some (
    Alt [|
      Seq [
        Token (Name "identifier");
        Opt (
          Token (Name "spec_target_signature_opt");
        );
      ];
      Token (Literal "module");
      Seq [
        Token (Literal "schema");
        Token (Name "identifier");
        Opt (
          Token (Name "type_params");
        );
      ];
    |];
  );
  "abort_expr",
  Some (
    Seq [
      Token (Literal "abort");
      Token (Name "expr");
    ];
  );
  "aborts_if",
  Some (
    Seq [
      Token (Literal "aborts_if");
      Opt (
        Token (Name "condition_props");
      );
      Token (Name "expr");
      Opt (
        Seq [
          Token (Literal "with");
          Token (Name "expr");
        ];
      );
    ];
  );
  "aborts_with_or_modifies",
  Some (
    Seq [
      Alt [|
        Token (Literal "aborts_with");
        Token (Literal "modifies");
      |];
      Opt (
        Token (Name "condition_props");
      );
      Token (Name "expr");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "expr");
        ];
      );
    ];
  );
  "access_field",
  Some (
    Seq [
      Alt [|
        Token (Name "access_field");
        Token (Name "receiver_call");
        Token (Name "mem_access");
        Token (Name "term");
      |];
      Token (Literal ".");
      Token (Name "identifier");
    ];
  );
  "asserts",
  Some (
    Seq [
      Alt [|
        Token (Literal "assert");
        Token (Literal "assume");
        Token (Literal "ensures");
        Token (Literal "requires");
      |];
      Opt (
        Token (Name "condition_props");
      );
      Token (Name "expr");
    ];
  );
  "assignment",
  Some (
    Seq [
      Token (Name "unary_expr");
      Token (Literal "=");
      Token (Name "expr");
    ];
  );
  "bin_op_expr",
  Some (
    Alt [|
      Seq [
        Token (Name "op_expr");
        Token (Literal "==>");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "<==>");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "||");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "&&");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "==");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "!=");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "<");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal ">");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "<=");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal ">=");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "..");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "|");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "^");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "&");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "<<");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal ">>");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "+");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "-");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "*");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "/");
        Token (Name "op_expr");
      ];
      Seq [
        Token (Name "op_expr");
        Token (Literal "%");
        Token (Name "op_expr");
      ];
    |];
  );
  "block",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "use_decl");
      );
      Repeat (
        Token (Name "sequence_item");
      );
      Opt (
        Token (Name "expr");
      );
      Token (Literal "}");
    ];
  );
  "call_args",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "expr");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "expr");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ")");
    ];
  );
  "call_expr",
  Some (
    Seq [
      Token (Name "name_access_chain");
      Opt (
        Token (Name "type_args");
      );
      Token (Name "call_args");
    ];
  );
  "cast_expr",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expr");
      Token (Literal "as");
      Token (Name "type_");
      Token (Literal ")");
    ];
  );
  "control_body",
  Some (
    Alt [|
      Token (Name "block");
      Token (Name "expr");
    |];
  );
  "deep_ellipsis",
  Some (
    Seq [
      Token (Literal "<...");
      Token (Name "expr");
      Token (Literal "...>");
    ];
  );
  "deref_expr",
  Some (
    Seq [
      Token (Literal "*");
      Token (Name "unary_expr");
    ];
  );
  "emits",
  Some (
    Seq [
      Token (Literal "emits");
      Opt (
        Token (Name "condition_props");
      );
      Token (Name "expr");
      Token (Literal "to");
      Token (Name "expr");
      Opt (
        Seq [
          Token (Literal "if");
          Token (Name "expr");
        ];
      );
    ];
  );
  "expr",
  Some (
    Alt [|
      Token (Name "assignment");
      Token (Name "op_expr");
      Token (Name "quantifier");
      Seq [
        Token (Name "lambda_bind_list");
        Token (Name "expr");
      ];
      Token (Name "ellipsis");
      Token (Name "deep_ellipsis");
      Token (Name "field_access_ellipsis_expr");
    |];
  );
  "expr_field",
  Some (
    Alt [|
      Token (Name "identifier");
      Seq [
        Token (Name "identifier");
        Token (Literal ":");
        Token (Name "expr");
      ];
      Token (Name "ellipsis");
    |];
  );
  "field_access_ellipsis_expr",
  Some (
    Seq [
      Alt [|
        Token (Name "access_field");
        Token (Name "receiver_call");
        Token (Name "mem_access");
        Token (Name "term");
      |];
      Token (Literal ".");
      Token (Name "ellipsis");
    ];
  );
  "for_loop_expr",
  Some (
    Alt [|
      Seq [
        Token (Literal "for");
        Token (Literal "(");
        Token (Name "var_name");
        Token (Literal "in");
        Token (Name "unary_expr");
        Token (Literal "..");
        Token (Name "unary_expr");
        Opt (
          Token (Name "spec_loop_invariant");
        );
        Token (Literal ")");
        Token (Name "block");
      ];
      Seq [
        Token (Literal "for");
        Token (Literal "(");
        Token (Name "ellipsis");
        Token (Literal ")");
        Token (Name "block");
      ];
    |];
  );
  "if_expr",
  Some (
    Seq [
      Token (Literal "if");
      Token (Name "parenthesized_expr");
      Token (Name "control_body");
      Opt (
        Seq [
          Token (Literal "else");
          Token (Name "control_body");
        ];
      );
    ];
  );
  "let_expr",
  Some (
    Seq [
      Token (Literal "let");
      Token (Name "bind_list");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "type_");
        ];
      );
      Opt (
        Seq [
          Token (Literal "=");
          Token (Name "expr");
        ];
      );
    ];
  );
  "loop_expr",
  Some (
    Seq [
      Token (Literal "loop");
      Token (Name "control_body");
    ];
  );
  "macro_call_expr",
  Some (
    Seq [
      Token (Name "name_access_chain");
      Token (Literal "!");
      Token (Name "call_args");
    ];
  );
  "mem_access",
  Some (
    Seq [
      Alt [|
        Token (Name "access_field");
        Token (Name "receiver_call");
        Token (Name "mem_access");
        Token (Name "term");
      |];
      Token (Literal "[");
      Token (Name "expr");
      Token (Literal "]");
    ];
  );
  "not_expr",
  Some (
    Seq [
      Token (Literal "!");
      Token (Name "unary_expr");
    ];
  );
  "op_expr",
  Some (
    Alt [|
      Token (Name "unary_expr");
      Token (Name "bin_op_expr");
    |];
  );
  "pack_expr",
  Some (
    Seq [
      Token (Name "name_access_chain");
      Opt (
        Token (Name "type_args");
      );
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "expr_field");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "expr_field");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "parenthesized_expr",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expr");
      Token (Literal ")");
    ];
  );
  "quantifier",
  Some (
    Alt [|
      Seq [
        Alt [|
          Token (Literal "forall");
          Token (Literal "exists");
        |];
        Token (Name "quantifier_bind");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "quantifier_bind");
          ];
        );
        Opt (
          Token (Name "triggers");
        );
        Opt (
          Seq [
            Token (Literal "where");
            Token (Name "expr");
          ];
        );
        Token (Literal ":");
        Token (Name "expr");
      ];
      Seq [
        Token (Literal "choose");
        Opt (
          Token (Literal "min");
        );
        Token (Name "quantifier_bind");
        Token (Literal "where");
        Token (Name "expr");
      ];
    |];
  );
  "quantifier_bind",
  Some (
    Alt [|
      Seq [
        Token (Name "identifier");
        Token (Literal ":");
        Token (Name "type_");
      ];
      Seq [
        Token (Name "identifier");
        Token (Literal "in");
        Token (Name "expr");
      ];
    |];
  );
  "receiver_call",
  Some (
    Seq [
      Alt [|
        Token (Name "access_field");
        Token (Name "receiver_call");
        Token (Name "mem_access");
        Token (Name "term");
      |];
      Token (Literal ".");
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal "::");
          Token (Name "type_args");
        ];
      );
      Token (Name "call_args");
    ];
  );
  "ref_expr",
  Some (
    Seq [
      Token (Literal "&");
      Token (Name "unary_expr");
    ];
  );
  "ref_mut_expr",
  Some (
    Seq [
      Token (Literal "&mut");
      Token (Name "unary_expr");
    ];
  );
  "return_expr",
  Some (
    Alt [|
      Token (Literal "return");
      Seq [
        Token (Literal "return");
        Token (Name "expr");
      ];
    |];
  );
  "sequence_item",
  Some (
    Alt [|
      Seq [
        Alt [|
          Token (Name "expr");
          Token (Name "let_expr");
        |];
        Token (Literal ";");
      ];
      Token (Name "ellipsis");
    |];
  );
  "spec_apply",
  Some (
    Seq [
      Token (Literal "apply");
      Token (Name "expr");
      Token (Literal "to");
      Opt (
        Seq [
          Token (Name "spec_apply_pattern");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "spec_apply_pattern");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Opt (
        Seq [
          Token (Literal "except");
          Opt (
            Seq [
              Token (Name "spec_apply_pattern");
              Repeat (
                Seq [
                  Token (Literal ",");
                  Token (Name "spec_apply_pattern");
                ];
              );
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal ";");
    ];
  );
  "spec_axiom",
  Some (
    Seq [
      Token (Literal "axiom");
      Opt (
        Token (Name "type_params");
      );
      Opt (
        Token (Name "condition_props");
      );
      Token (Name "expr");
      Token (Literal ";");
    ];
  );
  "spec_block",
  Some (
    Seq [
      Token (Literal "spec");
      Alt [|
        Token (Name "spec_func");
        Seq [
          Opt (
            Token (Name "spec_block_target");
          );
          Token (Literal "{");
          Repeat (
            Token (Name "use_decl");
          );
          Repeat (
            Token (Name "spec_block_member");
          );
          Token (Literal "}");
        ];
      |];
    ];
  );
  "spec_block_member",
  Some (
    Alt [|
      Alt [|
        Token (Name "spec_invariant");
        Token (Name "spec_condition");
        Token (Name "spec_func");
        Token (Name "spec_variable");
        Token (Name "spec_include");
        Token (Name "spec_apply");
        Token (Name "spec_pragma");
        Token (Name "spec_let");
        Token (Name "spec_update");
        Token (Name "spec_axiom");
      |];
      Token (Name "ellipsis");
    |];
  );
  "spec_condition",
  Some (
    Seq [
      Alt [|
        Token (Name "asserts");
        Token (Name "aborts_if");
        Token (Name "aborts_with_or_modifies");
        Token (Name "emits");
      |];
      Token (Literal ";");
    ];
  );
  "spec_func",
  Some (
    Alt [|
      Seq [
        Token (Literal "fun");
        Token (Name "spec_func_signatures");
        Alt [|
          Token (Name "block");
          Token (Literal ";");
        |];
      ];
      Seq [
        Token (Literal "native");
        Token (Literal "fun");
        Token (Name "spec_func_signatures");
        Token (Literal ";");
      ];
    |];
  );
  "spec_include",
  Some (
    Seq [
      Token (Literal "include");
      Opt (
        Token (Name "condition_props");
      );
      Token (Name "expr");
      Token (Literal ";");
    ];
  );
  "spec_invariant",
  Some (
    Seq [
      Token (Literal "invariant");
      Opt (
        Token (Name "type_params");
      );
      Opt (
        Token (Literal "update");
      );
      Opt (
        Token (Name "condition_props");
      );
      Token (Name "expr");
      Token (Literal ";");
    ];
  );
  "spec_let",
  Some (
    Seq [
      Token (Literal "let");
      Opt (
        Token (Literal "post");
      );
      Token (Name "var_name");
      Token (Literal "=");
      Token (Name "expr");
      Token (Literal ";");
    ];
  );
  "spec_loop_invariant", Some (Token (Name "spec_block"););
  "spec_update",
  Some (
    Seq [
      Token (Literal "update");
      Token (Name "assignment");
      Token (Literal ";");
    ];
  );
  "spec_variable",
  Some (
    Seq [
      Opt (
        Alt [|
          Token (Literal "global");
          Token (Literal "local");
        |];
      );
      Token (Name "identifier");
      Opt (
        Token (Name "type_params");
      );
      Token (Literal ":");
      Token (Name "type_");
      Opt (
        Seq [
          Token (Literal "=");
          Token (Name "expr");
        ];
      );
      Token (Literal ";");
    ];
  );
  "term",
  Some (
    Alt [|
      Token (Literal "break");
      Token (Literal "continue");
      Token (Name "vector_value_expr");
      Token (Name "value");
      Token (Name "tuple_expr");
      Token (Name "type_hint_expr");
      Token (Name "cast_expr");
      Token (Name "block");
      Alt [|
        Token (Name "var");
        Token (Name "call_expr");
        Token (Name "pack_expr");
        Token (Name "macro_call_expr");
      |];
      Token (Name "spec_block");
      Token (Name "if_expr");
      Token (Name "while_expr");
      Token (Name "loop_expr");
      Token (Name "return_expr");
      Token (Name "abort_expr");
      Token (Name "for_loop_expr");
    |];
  );
  "triggers",
  Some (
    Repeat1 (
      Seq [
        Token (Literal "{");
        Opt (
          Seq [
            Token (Name "expr");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "expr");
              ];
            );
          ];
        );
        Opt (
          Token (Literal ",");
        );
        Token (Literal "}");
      ];
    );
  );
  "tuple_expr",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "expr");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "expr");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ")");
    ];
  );
  "type_hint_expr",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expr");
      Token (Literal ":");
      Token (Name "type_");
      Token (Literal ")");
    ];
  );
  "unary_expr",
  Some (
    Alt [|
      Token (Name "not_expr");
      Token (Name "ref_expr");
      Token (Name "ref_mut_expr");
      Token (Name "deref_expr");
      Token (Name "move_expr");
      Token (Name "copy_expr");
      Alt [|
        Token (Name "access_field");
        Token (Name "receiver_call");
        Token (Name "mem_access");
        Token (Name "term");
      |];
      Token (Name "ellipsis");
      Token (Name "deep_ellipsis");
      Token (Name "field_access_ellipsis_expr");
      Token (Name "typed_metavariable");
    |];
  );
  "vector_value_expr",
  Some (
    Seq [
      Token (Literal "vector");
      Opt (
        Token (Name "type_args");
      );
      Token (Literal "[");
      Opt (
        Seq [
          Token (Name "expr");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "expr");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "]");
    ];
  );
  "while_expr",
  Some (
    Seq [
      Token (Literal "while");
      Token (Name "parenthesized_expr");
      Token (Name "control_body");
      Opt (
        Token (Name "spec_loop_invariant");
      );
    ];
  );
  "semgrep_expression",
  Some (
    Seq [
      Token (Literal "__SEMGREP_EXPRESSION");
      Alt [|
        Token (Name "expr");
        Token (Name "let_expr");
      |];
    ];
  );
  "script_spec_block",
  Some (
    Seq [
      Opt (
        Token (Name "attributes");
      );
      Token (Name "spec_block");
    ];
  );
  "constant_decl",
  Some (
    Seq [
      Token (Literal "const");
      Token (Name "identifier");
      Token (Literal ":");
      Token (Name "type_");
      Token (Literal "=");
      Token (Name "expr");
      Token (Literal ";");
    ];
  );
  "function_decl",
  Some (
    Seq [
      Opt (
        Token (Literal "inline");
      );
      Token (Literal "fun");
      Token (Name "identifier");
      Opt (
        Token (Name "type_params");
      );
      Token (Name "parameters");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "type_");
        ];
      );
      Opt (
        Token (Name "specifier");
      );
      Alt [|
        Token (Name "block");
        Token (Literal ";");
      |];
    ];
  );
  "semgrep_statement",
  Some (
    Seq [
      Token (Literal "__SEMGREP_STATEMENT");
      Repeat1 (
        Alt [|
          Token (Name "sequence_item");
          Token (Name "constant_decl");
        |];
      );
    ];
  );
  "script_constant_decl",
  Some (
    Seq [
      Opt (
        Token (Name "attributes");
      );
      Token (Name "constant_decl");
    ];
  );
  "declaration",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "attributes");
        );
        Alt [|
          Token (Name "use_decl");
          Token (Name "friend_decl");
          Seq [
            Token (Literal "spec");
            Token (Name "spec_func");
          ];
          Token (Name "spec_block");
          Token (Name "spec_invariant");
          Seq [
            Repeat (
              Token (Name "module_member_modifier");
            );
            Alt [|
              Token (Name "constant_decl");
              Token (Name "struct_decl");
              Token (Name "function_decl");
            |];
          ];
        |];
      ];
      Token (Name "ellipsis");
    |];
  );
  "script_func_decl",
  Some (
    Seq [
      Opt (
        Token (Name "attributes");
      );
      Repeat (
        Token (Name "module_member_modifier");
      );
      Token (Name "function_decl");
    ];
  );
  "module",
  Some (
    Seq [
      Alt [|
        Token (Literal "spec");
        Token (Name "module_ident");
      |];
      Opt (
        Seq [
          Token (Name "leading_name_access");
          Token (Literal "::");
        ];
      );
      Token (Name "identifier");
      Token (Literal "{");
      Repeat (
        Token (Name "declaration");
      );
      Token (Literal "}");
    ];
  );
  "script",
  Some (
    Seq [
      Token (Literal "script");
      Token (Literal "{");
      Repeat (
        Token (Name "script_user_decl");
      );
      Repeat (
        Token (Name "script_constant_decl");
      );
      Token (Name "script_func_decl");
      Repeat (
        Token (Name "script_spec_block");
      );
      Token (Literal "}");
    ];
  );
  "address_block",
  Some (
    Seq [
      Token (Literal "address");
      Token (Name "leading_name_access");
      Token (Literal "{");
      Repeat (
        Seq [
          Opt (
            Token (Name "attributes");
          );
          Token (Name "module");
        ];
      );
      Token (Literal "}");
    ];
  );
  "source_file",
  Some (
    Alt [|
      Repeat (
        Seq [
          Opt (
            Token (Name "attributes");
          );
          Alt [|
            Token (Name "module");
            Token (Name "script");
            Token (Name "address_block");
          |];
        ];
      );
      Token (Name "semgrep_expression");
      Token (Name "semgrep_statement");
    |];
  );
]

let trans_pat_0x ((kind, body) : mt) : CST.pat_0x =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_visibility ((kind, body) : mt) : CST.visibility =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Script (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Friend (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.trans_token (Run.matcher_token v2)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_number_type ((kind, body) : mt) : CST.number_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `U8 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `U16 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `U32 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `U64 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `U128 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `U256 (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_ellipsis ((kind, body) : mt) : CST.ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_quantifier_directive ((kind, body) : mt) : CST.quantifier_directive =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exists (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Forall (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Choose (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Min (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_tok_bdquot_rep_choice_imm_tok_bslash_choice_pat_9c2bd89_dquot ((kind, body) : mt) : CST.tok_bdquot_rep_choice_imm_tok_bslash_choice_pat_9c2bd89_dquot =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_phantom ((kind, body) : mt) : CST.phantom =
  match body with
  | Leaf v -> v
  | Children _ -> assert false



let trans_bool_literal ((kind, body) : mt) : CST.bool_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `True (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `False (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_pat_c1c0c3a ((kind, body) : mt) : CST.pat_c1c0c3a =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_0b ((kind, body) : mt) : CST.pat_0b =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_imm_tok_lt ((kind, body) : mt) : CST.imm_tok_lt =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_0o ((kind, body) : mt) : CST.pat_0o =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_module_ident ((kind, body) : mt) : CST.module_ident =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_reuseable_keywords ((kind, body) : mt) : CST.reuseable_keywords =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `For (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `While (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Friend (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pat_8bc5a9c ((kind, body) : mt) : CST.pat_8bc5a9c =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_57a456d ((kind, body) : mt) : CST.pat_57a456d =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_tok_xdquot_pat_92a0a93_dquot ((kind, body) : mt) : CST.tok_xdquot_pat_92a0a93_dquot =
  match body with
  | Leaf v -> v
  | Children _ -> assert false



let trans_pat_9bd0c11 ((kind, body) : mt) : CST.pat_9bd0c11 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_module_member_modifier ((kind, body) : mt) : CST.module_member_modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Visi (
            trans_visibility (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Native (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Entry (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_primitive_type ((kind, body) : mt) : CST.primitive_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Num_type (
            trans_number_type (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bool (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Addr (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Vec (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_ability ((kind, body) : mt) : CST.ability =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_copy (
            (match v with
            | Alt (0, v) ->
                `Copy (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Drop (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Store (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Key (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_attribute_name ((kind, body) : mt) : CST.attribute_name =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_spec_apply_fragment ((kind, body) : mt) : CST.spec_apply_fragment =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `STAR (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_copy_expr ((kind, body) : mt) : CST.copy_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_use_alias ((kind, body) : mt) : CST.use_alias =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_move_expr ((kind, body) : mt) : CST.move_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_byte_string ((kind, body) : mt) : CST.byte_string =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Tok_xdquot_pat_92a0a93_dquot (
            trans_tok_xdquot_pat_92a0a93_dquot (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Tok_bdquot_rep_choice_imm_tok_bslash_choice_pat_9c2bd89_dquot (
            trans_tok_bdquot_rep_choice_imm_tok_bslash_choice_pat_9c2bd89_dquot (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_number ((kind, body) : mt) : CST.number =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_57a456d (
            trans_pat_57a456d (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_0x_pat_c1c0c3a (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_0x (Run.matcher_token v0),
                  trans_pat_c1c0c3a (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Pat_0b_pat_8bc5a9c (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_0b (Run.matcher_token v0),
                  trans_pat_8bc5a9c (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Pat_0o_pat_9bd0c11 (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_0o (Run.matcher_token v0),
                  trans_pat_9bd0c11 (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_discouraged_name ((kind, body) : mt) : CST.discouraged_name =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Prim_type (
            trans_primitive_type (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Quan_dire (
            trans_quantifier_directive (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Reus_keywos (
            trans_reuseable_keywords (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_constraints ((kind, body) : mt) : CST.constraints =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_ability (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_ability (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_abilities ((kind, body) : mt) : CST.abilities =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_ability (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_ability (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_use_member ((kind, body) : mt) : CST.use_member =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id_opt_use_alias (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_use_alias (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_numerical_addr ((kind, body) : mt) : CST.numerical_addr =
  match body with
  | Children v ->
      trans_number (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_typed_number ((kind, body) : mt) : CST.typed_number =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_number (Run.matcher_token v0),
            trans_number_type (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_var_name ((kind, body) : mt) : CST.var_name =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Disc_name (
            trans_discouraged_name (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_param ((kind, body) : mt) : CST.type_param =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id_opt_consts (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_constraints (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_leading_name_access_wildcard ((kind, body) : mt) : CST.leading_name_access_wildcard =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Nume_addr (
            trans_numerical_addr (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Choice_id (
            (match v with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `STAR (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_leading_name_access ((kind, body) : mt) : CST.leading_name_access =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Nume_addr (
            trans_numerical_addr (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_params ((kind, body) : mt) : CST.type_params =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_type_param (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_type_param (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_struct_type_parameter ((kind, body) : mt) : CST.struct_type_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_phantom (Run.matcher_token v))
              v0
            ,
            trans_type_param (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_name_access_chain_wildcard ((kind, body) : mt) : CST.name_access_chain_wildcard =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_choice_id (
            (match v with
            | Alt (0, v) ->
                `Choice_id (
                  (match v with
                  | Alt (0, v) ->
                      `Id (
                        trans_identifier (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `STAR (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Disc_name (
                  trans_discouraged_name (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Choice_lead_name_access_wild_COLONCOLON_choice_id_opt_COLONCOLON_choice_id (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Lead_name_access_wild (
                        trans_leading_name_access_wildcard (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Disc_name (
                        trans_discouraged_name (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.trans_token (Run.matcher_token v1),
                  (match v2 with
                  | Alt (0, v) ->
                      `Id (
                        trans_identifier (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `STAR (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            (match v1 with
                            | Alt (0, v) ->
                                `Id (
                                  trans_identifier (Run.matcher_token v)
                                )
                            | Alt (1, v) ->
                                `STAR (
                                  Run.trans_token (Run.matcher_token v)
                                )
                            | _ -> assert false
                            )
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_module_ident_ ((kind, body) : mt) : CST.module_ident_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_leading_name_access (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_name_access_chain ((kind, body) : mt) : CST.name_access_chain =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_id (
            (match v with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Disc_name (
                  trans_discouraged_name (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Choice_lead_name_access_COLONCOLON_id_opt_COLONCOLON_id (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Lead_name_access (
                        trans_leading_name_access (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Disc_name (
                        trans_discouraged_name (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.trans_token (Run.matcher_token v1),
                  trans_identifier (Run.matcher_token v2),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_identifier (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_value ((kind, body) : mt) : CST.value =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `AT_lead_name_access (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_leading_name_access (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Bool_lit (
            trans_bool_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Num (
            trans_number (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Typed_num (
            trans_typed_number (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Byte_str (
            trans_byte_string (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_spec_apply_pattern ((kind, body) : mt) : CST.spec_apply_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Public (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Inte (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            Run.repeat1
              (fun v -> trans_spec_apply_fragment (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_type_params (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_struct_type_params ((kind, body) : mt) : CST.struct_type_params =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_struct_type_parameter (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_struct_type_parameter (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_use_decl ((kind, body) : mt) : CST.use_decl =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_module_ident_ (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Opt_use_alias (
                  Run.opt
                    (fun v -> trans_use_alias (Run.matcher_token v))
                    v
                )
            | Alt (1, v) ->
                `COLONCOLON_use_member (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_use_member (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `COLONCOLON_LCURL_opt_use_member_rep_COMMA_use_member_opt_COMMA_RCURL (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_use_member (Run.matcher_token v0),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            trans_use_member (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v1
                                )
                            | _ -> assert false
                            )
                          )
                          v2
                        ,
                        Run.opt
                          (fun v -> Run.trans_token (Run.matcher_token v))
                          v3
                        ,
                        Run.trans_token (Run.matcher_token v4)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_closure_type ((kind, body) : mt) : CST.closure_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_type__ (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_type__ (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_type__ (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_ref_type ((kind, body) : mt) : CST.ref_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `AMP_type (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_type_ (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `AMPmut_type (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_type_ (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_tuple_type ((kind, body) : mt) : CST.tuple_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_type__ (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_type__ (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_ ((kind, body) : mt) : CST.type_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_name_access_chain_opt_type_args (
            (match v with
            | Seq [v0; v1] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Name_access_chain (
                        trans_name_access_chain (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Prim_type (
                        trans_primitive_type (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.opt
                    (fun v -> trans_type_args (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Clos_type (
            trans_closure_type (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Tuple_type (
            trans_tuple_type (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type__ ((kind, body) : mt) : CST.type__ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type (
            trans_type_ (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Ref_type (
            trans_ref_type (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_args ((kind, body) : mt) : CST.type_args =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_imm_tok_lt (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_type__ (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_type__ (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_friend_decl ((kind, body) : mt) : CST.friend_decl =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_name_access_chain (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_attribute_val ((kind, body) : mt) : CST.attribute_val =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Value (
            trans_value (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Name_access_chain (
            trans_name_access_chain (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_spec_pragma_prop ((kind, body) : mt) : CST.spec_pragma_prop =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_var_name (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Value (
                            trans_value (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Name_access_chain (
                            trans_name_access_chain (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_struct_def_name ((kind, body) : mt) : CST.struct_def_name =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_struct_type_params (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_var ((kind, body) : mt) : CST.var =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_name_access_chain (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_args (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_typed_metavariable ((kind, body) : mt) : CST.typed_metavariable =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_type__ (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_bind ((kind, body) : mt) : CST.bind =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Var_name (
            trans_var_name (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Name_access_chain_opt_type_args_bind_fields (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_name_access_chain (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_type_args (Run.matcher_token v))
                    v1
                  ,
                  trans_bind_fields (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bind_field ((kind, body) : mt) : CST.bind_field =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_var_name (
            (match v with
            | Alt (0, v) ->
                `Var_name (
                  trans_var_name (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Var_name_COLON_bind (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        trans_var_name (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1),
                        trans_bind (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bind_fields ((kind, body) : mt) : CST.bind_fields =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_bind_field (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_bind_field (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_address_specifier ((kind, body) : mt) : CST.address_specifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `STAR (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Nume_addr (
            trans_numerical_addr (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Name_access_chain_opt_opt_type_args_LPAR_id_RPAR (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_name_access_chain (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1; v2; v3] ->
                          (
                            Run.opt
                              (fun v -> trans_type_args (Run.matcher_token v))
                              v0
                            ,
                            Run.trans_token (Run.matcher_token v1),
                            trans_identifier (Run.matcher_token v2),
                            Run.trans_token (Run.matcher_token v3)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_parameter ((kind, body) : mt) : CST.parameter =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id_COLON_type_ (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_type__ (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_field_annot ((kind, body) : mt) : CST.field_annot =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id_COLON_type_ (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_type__ (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_attribute ((kind, body) : mt) : CST.attribute =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_attr_name (
            (match v with
            | Alt (0, v) ->
                `Attr_name (
                  trans_attribute_name (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Attr_name_EQ_attr_val (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        trans_attribute_name (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1),
                        trans_attribute_val (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Attr_name_LPAR_opt_attr_rep_COMMA_attr_opt_COMMA_RPAR (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4] ->
                      (
                        trans_attribute_name (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_attribute (Run.matcher_token v0),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            trans_attribute (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v1
                                )
                            | _ -> assert false
                            )
                          )
                          v2
                        ,
                        Run.opt
                          (fun v -> Run.trans_token (Run.matcher_token v))
                          v3
                        ,
                        Run.trans_token (Run.matcher_token v4)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_condition_props ((kind, body) : mt) : CST.condition_props =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_spec_pragma_prop (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_spec_pragma_prop (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_spec_pragma ((kind, body) : mt) : CST.spec_pragma =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_spec_pragma_prop (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_spec_pragma_prop (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_bind_list ((kind, body) : mt) : CST.bind_list =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Bind (
            trans_bind (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `LPAR_opt_bind_rep_COMMA_bind_opt_COMMA_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_bind (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_bind (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v2
                  ,
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_lambda_bind_list ((kind, body) : mt) : CST.lambda_bind_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_bind (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_bind (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_access_specifier ((kind, body) : mt) : CST.access_specifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_name_access_chain_wildcard (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_args (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_address_specifier (Run.matcher_token v1),
                      Run.trans_token (Run.matcher_token v2)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_parameters ((kind, body) : mt) : CST.parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_parameter (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_parameter (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_struct_body ((kind, body) : mt) : CST.struct_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_field_annot (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_field_annot (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_attributes ((kind, body) : mt) : CST.attributes =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Seq [v0; v1; v2; v3; v4] ->
              (
                Run.trans_token (Run.matcher_token v0),
                Run.trans_token (Run.matcher_token v1),
                Run.opt
                  (fun v ->
                    (match v with
                    | Seq [v0; v1] ->
                        (
                          trans_attribute (Run.matcher_token v0),
                          Run.repeat
                            (fun v ->
                              (match v with
                              | Seq [v0; v1] ->
                                  (
                                    Run.trans_token (Run.matcher_token v0),
                                    trans_attribute (Run.matcher_token v1)
                                  )
                              | _ -> assert false
                              )
                            )
                            v1
                        )
                    | _ -> assert false
                    )
                  )
                  v2
                ,
                Run.opt
                  (fun v -> Run.trans_token (Run.matcher_token v))
                  v3
                ,
                Run.trans_token (Run.matcher_token v4)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

let trans_access_specifier_list ((kind, body) : mt) : CST.access_specifier_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_access_specifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_access_specifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_spec_target_signature_opt ((kind, body) : mt) : CST.spec_target_signature_opt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> trans_type_params (Run.matcher_token v))
              v0
            ,
            trans_parameters (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type__ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_spec_func_signatures ((kind, body) : mt) : CST.spec_func_signatures =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_params (Run.matcher_token v))
              v1
            ,
            trans_parameters (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_type__ (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_struct_decl ((kind, body) : mt) : CST.struct_decl =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_struct_def_name (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_abilities (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            (match v3 with
            | Alt (0, v) ->
                `Struct_body (
                  trans_struct_body (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `SEMI (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_script_user_decl ((kind, body) : mt) : CST.script_user_decl =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_attributes (Run.matcher_token v))
              v0
            ,
            trans_use_decl (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_specifier ((kind, body) : mt) : CST.specifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pure (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Rep1_opt_BANG_choice_acquis_access_spec_list (
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v0
                      ,
                      (match v1 with
                      | Alt (0, v) ->
                          `Acquis (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Reads (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Writes (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      trans_access_specifier_list (Run.matcher_token v2)
                    )
                | _ -> assert false
                )
              )
              v
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_spec_block_target ((kind, body) : mt) : CST.spec_block_target =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id_opt_spec_target_sign_opt (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      trans_spec_target_signature_opt (Run.matcher_token v)
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Module (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Schema_id_opt_type_params (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_identifier (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_type_params (Run.matcher_token v))
                    v2
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_abort_expr ((kind, body) : mt) : CST.abort_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expr (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_aborts_if ((kind, body) : mt) : CST.aborts_if =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_condition_props (Run.matcher_token v))
              v1
            ,
            trans_expr (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expr (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_aborts_with_or_modifies ((kind, body) : mt) : CST.aborts_with_or_modifies =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Aborts_with (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Modifs (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_condition_props (Run.matcher_token v))
              v1
            ,
            trans_expr (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expr (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_access_field ((kind, body) : mt) : CST.access_field =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Access_field (
                  trans_access_field (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Rece_call (
                  trans_receiver_call (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Mem_access (
                  trans_mem_access (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Term (
                  trans_term (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_asserts ((kind, body) : mt) : CST.asserts =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Assert (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Assume (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Ensures (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Requis (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_condition_props (Run.matcher_token v))
              v1
            ,
            trans_expr (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assignment ((kind, body) : mt) : CST.assignment =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_unary_expr (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expr (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bin_op_expr ((kind, body) : mt) : CST.bin_op_expr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Op_expr_EQEQGT_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Op_expr_LTEQEQGT_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Op_expr_BARBAR_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Op_expr_AMPAMP_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Op_expr_EQEQ_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Op_expr_BANGEQ_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Op_expr_LT_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Op_expr_GT_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Op_expr_LTEQ_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `Op_expr_GTEQ_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (10, v) ->
          `Op_expr_DOTDOT_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (11, v) ->
          `Op_expr_BAR_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (12, v) ->
          `Op_expr_HAT_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (13, v) ->
          `Op_expr_AMP_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (14, v) ->
          `Op_expr_LTLT_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (15, v) ->
          `Op_expr_GTGT_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (16, v) ->
          `Op_expr_PLUS_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (17, v) ->
          `Op_expr_DASH_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (18, v) ->
          `Op_expr_STAR_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (19, v) ->
          `Op_expr_SLASH_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (20, v) ->
          `Op_expr_PERC_op_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_op_expr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_op_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_block ((kind, body) : mt) : CST.block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_use_decl (Run.matcher_token v))
              v1
            ,
            Run.repeat
              (fun v -> trans_sequence_item (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_expr (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call_args ((kind, body) : mt) : CST.call_args =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_expr (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_expr (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call_expr ((kind, body) : mt) : CST.call_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_name_access_chain (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_args (Run.matcher_token v))
              v1
            ,
            trans_call_args (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_cast_expr ((kind, body) : mt) : CST.cast_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expr (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_type__ (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_control_body ((kind, body) : mt) : CST.control_body =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Blk (
            trans_block (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Expr (
            trans_expr (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_deep_ellipsis ((kind, body) : mt) : CST.deep_ellipsis =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expr (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_deref_expr ((kind, body) : mt) : CST.deref_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_unary_expr (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_emits ((kind, body) : mt) : CST.emits =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_condition_props (Run.matcher_token v))
              v1
            ,
            trans_expr (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expr (Run.matcher_token v4),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expr (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v5
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expr ((kind, body) : mt) : CST.expr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Assign (
            trans_assignment (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Op_expr (
            trans_op_expr (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Quan (
            trans_quantifier (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Lambda_bind_list_expr (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_lambda_bind_list (Run.matcher_token v0),
                  trans_expr (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Deep_ellips (
            trans_deep_ellipsis (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Field_access_ellips_expr (
            trans_field_access_ellipsis_expr (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expr_field ((kind, body) : mt) : CST.expr_field =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Id_COLON_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_field_access_ellipsis_expr ((kind, body) : mt) : CST.field_access_ellipsis_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Access_field (
                  trans_access_field (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Rece_call (
                  trans_receiver_call (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Mem_access (
                  trans_mem_access (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Term (
                  trans_term (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_ellipsis (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_loop_expr ((kind, body) : mt) : CST.for_loop_expr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `For_LPAR_var_name_in_un_expr_DOTDOT_un_expr_opt_spec_loop_inva_RPAR_blk (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8; v9] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_var_name (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3),
                  trans_unary_expr (Run.matcher_token v4),
                  Run.trans_token (Run.matcher_token v5),
                  trans_unary_expr (Run.matcher_token v6),
                  Run.opt
                    (fun v -> trans_spec_loop_invariant (Run.matcher_token v))
                    v7
                  ,
                  Run.trans_token (Run.matcher_token v8),
                  trans_block (Run.matcher_token v9)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `For_LPAR_ellips_RPAR_blk (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_ellipsis (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3),
                  trans_block (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_expr ((kind, body) : mt) : CST.if_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_parenthesized_expr (Run.matcher_token v1),
            trans_control_body (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_control_body (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_let_expr ((kind, body) : mt) : CST.let_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_bind_list (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type__ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expr (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_loop_expr ((kind, body) : mt) : CST.loop_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_control_body (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_macro_call_expr ((kind, body) : mt) : CST.macro_call_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_name_access_chain (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_call_args (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_mem_access ((kind, body) : mt) : CST.mem_access =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Access_field (
                  trans_access_field (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Rece_call (
                  trans_receiver_call (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Mem_access (
                  trans_mem_access (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Term (
                  trans_term (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_expr (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_not_expr ((kind, body) : mt) : CST.not_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_unary_expr (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_op_expr ((kind, body) : mt) : CST.op_expr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Un_expr (
            trans_unary_expr (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bin_op_expr (
            trans_bin_op_expr (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pack_expr ((kind, body) : mt) : CST.pack_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            trans_name_access_chain (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_args (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_expr_field (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_expr_field (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parenthesized_expr ((kind, body) : mt) : CST.parenthesized_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expr (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_quantifier ((kind, body) : mt) : CST.quantifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_forall_quan_bind_rep_COMMA_quan_bind_opt_triggs_opt_where_expr_COLON_expr (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Forall (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Exists (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_quantifier_bind (Run.matcher_token v1),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_quantifier_bind (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                  ,
                  Run.opt
                    (fun v -> trans_triggers (Run.matcher_token v))
                    v3
                  ,
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_expr (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v4
                  ,
                  Run.trans_token (Run.matcher_token v5),
                  trans_expr (Run.matcher_token v6)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Choose_opt_min_quan_bind_where_expr (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v1
                  ,
                  trans_quantifier_bind (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3),
                  trans_expr (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_quantifier_bind ((kind, body) : mt) : CST.quantifier_bind =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id_COLON_type_ (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_type__ (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Id_in_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_receiver_call ((kind, body) : mt) : CST.receiver_call =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Access_field (
                  trans_access_field (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Rece_call (
                  trans_receiver_call (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Mem_access (
                  trans_mem_access (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Term (
                  trans_term (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_args (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            trans_call_args (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_ref_expr ((kind, body) : mt) : CST.ref_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_unary_expr (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_ref_mut_expr ((kind, body) : mt) : CST.ref_mut_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_unary_expr (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_return_expr ((kind, body) : mt) : CST.return_expr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Ret (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Ret_expr (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expr (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_sequence_item ((kind, body) : mt) : CST.sequence_item =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_expr_SEMI (
            (match v with
            | Seq [v0; v1] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Expr (
                        trans_expr (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Let_expr (
                        trans_let_expr (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_apply ((kind, body) : mt) : CST.spec_apply =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expr (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_spec_apply_pattern (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_spec_apply_pattern (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      Run.opt
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                trans_spec_apply_pattern (Run.matcher_token v0),
                                Run.repeat
                                  (fun v ->
                                    (match v with
                                    | Seq [v0; v1] ->
                                        (
                                          Run.trans_token (Run.matcher_token v0),
                                          trans_spec_apply_pattern (Run.matcher_token v1)
                                        )
                                    | _ -> assert false
                                    )
                                  )
                                  v1
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v5
            ,
            Run.trans_token (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_axiom ((kind, body) : mt) : CST.spec_axiom =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_params (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_condition_props (Run.matcher_token v))
              v2
            ,
            trans_expr (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_block ((kind, body) : mt) : CST.spec_block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Spec_func (
                  trans_spec_func (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Opt_spec_blk_target_LCURL_rep_use_decl_rep_spec_blk_member_RCURL (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4] ->
                      (
                        Run.opt
                          (fun v -> trans_spec_block_target (Run.matcher_token v))
                          v0
                        ,
                        Run.trans_token (Run.matcher_token v1),
                        Run.repeat
                          (fun v -> trans_use_decl (Run.matcher_token v))
                          v2
                        ,
                        Run.repeat
                          (fun v -> trans_spec_block_member (Run.matcher_token v))
                          v3
                        ,
                        Run.trans_token (Run.matcher_token v4)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_block_member ((kind, body) : mt) : CST.spec_block_member =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_spec_inva (
            (match v with
            | Alt (0, v) ->
                `Spec_inva (
                  trans_spec_invariant (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Spec_cond (
                  trans_spec_condition (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Spec_func (
                  trans_spec_func (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Spec_var (
                  trans_spec_variable (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Spec_incl (
                  trans_spec_include (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `Spec_apply (
                  trans_spec_apply (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `Spec_pragma (
                  trans_spec_pragma (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `Spec_let (
                  trans_spec_let (Run.matcher_token v)
                )
            | Alt (8, v) ->
                `Spec_update (
                  trans_spec_update (Run.matcher_token v)
                )
            | Alt (9, v) ->
                `Spec_axiom (
                  trans_spec_axiom (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_condition ((kind, body) : mt) : CST.spec_condition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Asserts (
                  trans_asserts (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Aborts_if (
                  trans_aborts_if (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Aborts_with_or_modifs (
                  trans_aborts_with_or_modifies (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Emits (
                  trans_emits (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_func ((kind, body) : mt) : CST.spec_func =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Fun_spec_func_signas_choice_blk (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_spec_func_signatures (Run.matcher_token v1),
                  (match v2 with
                  | Alt (0, v) ->
                      `Blk (
                        trans_block (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `SEMI (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Native_fun_spec_func_signas_SEMI (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_spec_func_signatures (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_include ((kind, body) : mt) : CST.spec_include =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_condition_props (Run.matcher_token v))
              v1
            ,
            trans_expr (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_invariant ((kind, body) : mt) : CST.spec_invariant =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_params (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_condition_props (Run.matcher_token v))
              v3
            ,
            trans_expr (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_let ((kind, body) : mt) : CST.spec_let =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            trans_var_name (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expr (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_loop_invariant ((kind, body) : mt) : CST.spec_loop_invariant =
  match body with
  | Children v ->
      trans_spec_block (Run.matcher_token v)
  | Leaf _ -> assert false

and trans_spec_update ((kind, body) : mt) : CST.spec_update =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_assignment (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_variable ((kind, body) : mt) : CST.spec_variable =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Global (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Local (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_type_params (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_type__ (Run.matcher_token v4),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expr (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v5
            ,
            Run.trans_token (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_term ((kind, body) : mt) : CST.term =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Brk (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Cont (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Vec_value_expr (
            trans_vector_value_expr (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Value (
            trans_value (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Tuple_expr (
            trans_tuple_expr (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Type_hint_expr (
            trans_type_hint_expr (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Cast_expr (
            trans_cast_expr (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Blk (
            trans_block (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Choice_var (
            (match v with
            | Alt (0, v) ->
                `Var (
                  trans_var (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Call_expr (
                  trans_call_expr (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Pack_expr (
                  trans_pack_expr (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Macro_call_expr (
                  trans_macro_call_expr (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `Spec_blk (
            trans_spec_block (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `If_expr (
            trans_if_expr (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `While_expr (
            trans_while_expr (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Loop_expr (
            trans_loop_expr (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Ret_expr (
            trans_return_expr (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Abort_expr (
            trans_abort_expr (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `For_loop_expr (
            trans_for_loop_expr (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_triggers ((kind, body) : mt) : CST.triggers =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Seq [v0; v1; v2; v3] ->
              (
                Run.trans_token (Run.matcher_token v0),
                Run.opt
                  (fun v ->
                    (match v with
                    | Seq [v0; v1] ->
                        (
                          trans_expr (Run.matcher_token v0),
                          Run.repeat
                            (fun v ->
                              (match v with
                              | Seq [v0; v1] ->
                                  (
                                    Run.trans_token (Run.matcher_token v0),
                                    trans_expr (Run.matcher_token v1)
                                  )
                              | _ -> assert false
                              )
                            )
                            v1
                        )
                    | _ -> assert false
                    )
                  )
                  v1
                ,
                Run.opt
                  (fun v -> Run.trans_token (Run.matcher_token v))
                  v2
                ,
                Run.trans_token (Run.matcher_token v3)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

and trans_tuple_expr ((kind, body) : mt) : CST.tuple_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_expr (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_expr (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_hint_expr ((kind, body) : mt) : CST.type_hint_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expr (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_type__ (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_expr ((kind, body) : mt) : CST.unary_expr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Not_expr (
            trans_not_expr (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Ref_expr (
            trans_ref_expr (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Ref_mut_expr (
            trans_ref_mut_expr (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Deref_expr (
            trans_deref_expr (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Move_expr (
            trans_move_expr (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Copy_expr (
            trans_copy_expr (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Choice_access_field (
            (match v with
            | Alt (0, v) ->
                `Access_field (
                  trans_access_field (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Rece_call (
                  trans_receiver_call (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Mem_access (
                  trans_mem_access (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Term (
                  trans_term (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Deep_ellips (
            trans_deep_ellipsis (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Field_access_ellips_expr (
            trans_field_access_ellipsis_expr (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Typed_meta (
            trans_typed_metavariable (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_vector_value_expr ((kind, body) : mt) : CST.vector_value_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_args (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_expr (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_expr (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_while_expr ((kind, body) : mt) : CST.while_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_parenthesized_expr (Run.matcher_token v1),
            trans_control_body (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_spec_loop_invariant (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_semgrep_expression ((kind, body) : mt) : CST.semgrep_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Expr (
                  trans_expr (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Let_expr (
                  trans_let_expr (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_script_spec_block ((kind, body) : mt) : CST.script_spec_block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_attributes (Run.matcher_token v))
              v0
            ,
            trans_spec_block (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_constant_decl ((kind, body) : mt) : CST.constant_decl =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_type__ (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4),
            trans_expr (Run.matcher_token v5),
            Run.trans_token (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_function_decl ((kind, body) : mt) : CST.function_decl =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_params (Run.matcher_token v))
              v3
            ,
            trans_parameters (Run.matcher_token v4),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type__ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v5
            ,
            Run.opt
              (fun v -> trans_specifier (Run.matcher_token v))
              v6
            ,
            (match v7 with
            | Alt (0, v) ->
                `Blk (
                  trans_block (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `SEMI (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_semgrep_statement ((kind, body) : mt) : CST.semgrep_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Seq_item (
                      trans_sequence_item (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Cst_decl (
                      trans_constant_decl (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_script_constant_decl ((kind, body) : mt) : CST.script_constant_decl =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_attributes (Run.matcher_token v))
              v0
            ,
            trans_constant_decl (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_declaration ((kind, body) : mt) : CST.declaration =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_attris_choice_use_decl (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v -> trans_attributes (Run.matcher_token v))
                    v0
                  ,
                  (match v1 with
                  | Alt (0, v) ->
                      `Use_decl (
                        trans_use_decl (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Friend_decl (
                        trans_friend_decl (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `Spec_spec_func (
                        (match v with
                        | Seq [v0; v1] ->
                            (
                              Run.trans_token (Run.matcher_token v0),
                              trans_spec_func (Run.matcher_token v1)
                            )
                        | _ -> assert false
                        )
                      )
                  | Alt (3, v) ->
                      `Spec_blk (
                        trans_spec_block (Run.matcher_token v)
                      )
                  | Alt (4, v) ->
                      `Spec_inva (
                        trans_spec_invariant (Run.matcher_token v)
                      )
                  | Alt (5, v) ->
                      `Rep_module_member_modi_choice_cst_decl (
                        (match v with
                        | Seq [v0; v1] ->
                            (
                              Run.repeat
                                (fun v ->
                                  trans_module_member_modifier (Run.matcher_token v)
                                )
                                v0
                              ,
                              (match v1 with
                              | Alt (0, v) ->
                                  `Cst_decl (
                                    trans_constant_decl (Run.matcher_token v)
                                  )
                              | Alt (1, v) ->
                                  `Struct_decl (
                                    trans_struct_decl (Run.matcher_token v)
                                  )
                              | Alt (2, v) ->
                                  `Func_decl (
                                    trans_function_decl (Run.matcher_token v)
                                  )
                              | _ -> assert false
                              )
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_script_func_decl ((kind, body) : mt) : CST.script_func_decl =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> trans_attributes (Run.matcher_token v))
              v0
            ,
            Run.repeat
              (fun v ->
                trans_module_member_modifier (Run.matcher_token v)
              )
              v1
            ,
            trans_function_decl (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_module_ ((kind, body) : mt) : CST.module_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Spec (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Module_id (
                  trans_module_ident (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_leading_name_access (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_identifier (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            Run.repeat
              (fun v -> trans_declaration (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_script ((kind, body) : mt) : CST.script =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_script_user_decl (Run.matcher_token v))
              v2
            ,
            Run.repeat
              (fun v -> trans_script_constant_decl (Run.matcher_token v))
              v3
            ,
            trans_script_func_decl (Run.matcher_token v4),
            Run.repeat
              (fun v -> trans_script_spec_block (Run.matcher_token v))
              v5
            ,
            Run.trans_token (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_address_block ((kind, body) : mt) : CST.address_block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_leading_name_access (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.opt
                        (fun v -> trans_attributes (Run.matcher_token v))
                        v0
                      ,
                      trans_module_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_source_file ((kind, body) : mt) : CST.source_file =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Rep_opt_attris_choice_module (
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.opt
                        (fun v -> trans_attributes (Run.matcher_token v))
                        v0
                      ,
                      (match v1 with
                      | Alt (0, v) ->
                          `Module (
                            trans_module_ (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Script (
                            trans_script (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Addr_blk (
                            trans_address_block (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v
          )
      | Alt (1, v) ->
          `Semg_exp (
            trans_semgrep_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Semg_stmt (
            trans_semgrep_statement (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let root_node = Run.remove_extras ~extras orig_root_node in
  let matched_tree = Run.match_tree children_regexps src root_node in
  let opt_program = Option.map trans_source_file matched_tree in
  Parsing_result.create src opt_program errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

